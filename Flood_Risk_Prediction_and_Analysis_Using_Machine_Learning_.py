{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/Nandan-2004/Flood-Risk-Prediction-and-Analysis-Using-Machine-Learning/blob/main/Flood_Risk_Prediction_and_Analysis_Using_Machine_Learning_.py\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# Import Libraries\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.preprocessing import LabelEncoder\n",
        "from sklearn.linear_model import LogisticRegression\n",
        "from sklearn.ensemble import RandomForestClassifier\n",
        "from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n",
        "\n",
        "import streamlit as st\n",
        "import joblib\n",
        "import os\n",
        "try:\n",
        "    import kagglehub\n",
        "except ImportError:\n",
        "    kagglehub = None\n",
        "    print(\"‚ö†Ô∏è kagglehub not installed, please install with: pip install kagglehub\")\n",
        "# Load Dataset\n",
        "# List of Indian states with approximate coordinates for demonstration\n",
        "state_coords = {\n",
        "    \"Andhra Pradesh\": (15.9129, 79.7400),\n",
        "    \"Arunachal Pradesh\": (28.2180, 94.7278),\n",
        "    \"Assam\": (26.2006, 92.9376),\n",
        "    \"Bihar\": (25.0961, 85.3131),\n",
        "    \"Chhattisgarh\": (21.2787, 81.8661),\n",
        "    \"Goa\": (15.2993, 74.1240),\n",
        "    \"Gujarat\": (22.2587, 71.1924),\n",
        "    \"Haryana\": (29.0588, 76.0856),\n",
        "    \"Himachal Pradesh\": (31.1048, 77.1734),\n",
        "    \"Jharkhand\": (23.6102, 85.2799),\n",
        "    \"Karnataka\": (15.3173, 75.7139),\n",
        "    \"Kerala\": (10.8505, 76.2711),\n",
        "    \"Madhya Pradesh\": (22.9734, 78.6569),\n",
        "    \"Maharashtra\": (19.7515, 75.7139),\n",
        "    \"Manipur\": (24.6637, 93.9063),\n",
        "    \"Meghalaya\": (25.4670, 91.3662),\n",
        "    \"Mizoram\": (23.1645, 92.9376),\n",
        "    \"Nagaland\": (26.1584, 94.5624),\n",
        "    \"Odisha\": (20.9517, 85.0985),\n",
        "    \"Punjab\": (31.1471, 75.3412),\n",
        "    \"Rajasthan\": (27.0238, 74.2179),\n",
        "    \"Sikkim\": (27.5330, 88.5122),\n",
        "    \"Tamil Nadu\": (11.1271, 78.6569),\n",
        "    \"Telangana\": (18.1124, 79.0193),\n",
        "    \"Tripura\": (23.9408, 91.9882),\n",
        "    \"Uttar Pradesh\": (26.8467, 80.9462),\n",
        "    \"Uttarakhand\": (30.0668, 79.0193),\n",
        "    \"West Bengal\": (22.9868, 87.8550),\n",
        "    \"Delhi\": (28.7041, 77.1025),\n",
        "}\n",
        "\n",
        "# Add a synthetic 'state' column to the dataset (randomly assigned for demonstration)\n",
        "def load_data():\n",
        "    if kagglehub:\n",
        "        # Download dataset from Kaggle using kagglehub\n",
        "        path = kagglehub.dataset_download(\"naiyakhalid/flood-prediction-dataset\")\n",
        "        for fname in [\"flood.csv\", \"flood_data.csv\"]:\n",
        "            csv_file_path = os.path.join(path, fname)\n",
        "            if os.path.exists(csv_file_path):\n",
        "                break\n",
        "        else:\n",
        "            raise FileNotFoundError(f\"No flood dataset found in {path}. Checked flood.csv and flood_data.csv.\")\n",
        "    else:\n",
        "        csv_file_path = \"flood_data.csv\"\n",
        "\n",
        "    # Load dataset\n",
        "    df = pd.read_csv(csv_file_path)\n",
        "\n",
        "    states = list(state_coords.keys())\n",
        "    np.random.seed(42)\n",
        "    df['state'] = np.random.choice(states, size=len(df))\n",
        "\n",
        "    # Synthetic flood risk label\n",
        "    df['flood_risk'] = np.where(\n",
        "        (df['MonsoonIntensity'] + df['TopographyDrainage'] + df['RiverManagement']) > 15,\n",
        "        'High', 'Low'\n",
        "    )\n",
        "\n",
        "    # Feature/target split\n",
        "    X = df.drop(columns=['flood_risk'])\n",
        "    y = df['flood_risk']\n",
        "\n",
        "    # Encode labels\n",
        "    le = LabelEncoder()\n",
        "    y = le.fit_transform(y)\n",
        "\n",
        "    # Train Random Forest model\n",
        "    rf = RandomForestClassifier(n_estimators=100, random_state=42)\n",
        "    rf.fit(X.drop(columns=['state']), y)\n",
        "\n",
        "    return X, rf, le, df\n",
        "\n",
        "X, rf, le, df = load_data()\n",
        "\n",
        "# Streamlit App\n",
        "st.title(\"üåä Flood Risk Prediction using Machine Learning\")\n",
        "st.write(\"Enter environmental and socio-economic factors below to predict flood risk.\")\n",
        "\n",
        "# Streamlit UI for state selection\n",
        "st.sidebar.header(\"Location Selection\")\n",
        "states = list(state_coords.keys())\n",
        "selected_state = st.sidebar.selectbox(\"Select your state\", states)\n",
        "\n",
        "# Use mean values for sliders based on selected state\n",
        "def get_state_means(state):\n",
        "    state_data = df[df['state'] == state]\n",
        "    means = {}\n",
        "    for col in X.columns:\n",
        "        if col != 'state':\n",
        "            means[col] = int(state_data[col].mean()) if not state_data.empty else 5\n",
        "    return means\n",
        "\n",
        "means = get_state_means(selected_state)\n",
        "user_inputs = []\n",
        "for col in X.columns:\n",
        "    if col != 'state':\n",
        "        val = st.slider(col, 0, 10, means[col])\n",
        "        user_inputs.append(val)\n",
        "\n",
        "# Create input DataFrame\n",
        "input_data = pd.DataFrame([user_inputs], columns=[col for col in X.columns if col != 'state'])\n",
        "\n",
        "# Prediction button\n",
        "if st.button(\"Predict Flood Risk\"):\n",
        "    prediction = rf.predict(input_data)\n",
        "    predicted_label = le.inverse_transform(prediction)[0]\n",
        "    if predicted_label == \"High\":\n",
        "        st.error(f\"‚ö†Ô∏è High Flood Risk Detected in {selected_state}!\")\n",
        "    else:\n",
        "        st.success(f\"‚úÖ Low Flood Risk in {selected_state}\")\n",
        "\n",
        "# EDA and Visualization\n",
        "if st.checkbox(\"Show Data Insights & Visualizations\"):\n",
        "    st.subheader(\"Dataset Preview\")\n",
        "    st.dataframe(X.head())\n",
        "\n",
        "    st.subheader(\"Feature Distributions\")\n",
        "    import matplotlib.pyplot as plt\n",
        "    import seaborn as sns\n",
        "    import io\n",
        "    import base64\n",
        "    fig, ax = plt.subplots(figsize=(15, 6))\n",
        "    X.hist(ax=ax, bins=20)\n",
        "    st.pyplot(fig)\n",
        "\n",
        "    st.subheader(\"Correlation Heatmap\")\n",
        "    fig2, ax2 = plt.subplots(figsize=(12, 10))\n",
        "    sns.heatmap(X.corr(), annot=True, cmap='coolwarm', ax=ax2)\n",
        "    st.pyplot(fig2)\n",
        "\n",
        "    st.subheader(\"Flood Risk Distribution\")\n",
        "    fig3, ax3 = plt.subplots()\n",
        "    sns.countplot(x=le.inverse_transform(rf.predict(X)), ax=ax3)\n",
        "    ax3.set_title(\"Flood Risk Distribution (Predicted)\")\n",
        "    st.pyplot(fig3)\n",
        "\n",
        "# Map Visualization for selected state\n",
        "if st.checkbox(\"Show High Flood Risk Locations on Map\"):\n",
        "    import folium\n",
        "    from streamlit_folium import st_folium\n",
        "    m = folium.Map(location=[20.5937, 78.9629], zoom_start=5)\n",
        "    for state, (lat, lon) in state_coords.items():\n",
        "        color = \"red\" if state == selected_state else \"blue\"\n",
        "        folium.CircleMarker(\n",
        "            location=[lat, lon],\n",
        "            radius=10 if state == selected_state else 7,\n",
        "            popup=f\"{state}\",\n",
        "            color=color,\n",
        "            fill=True,\n",
        "            fill_color=color\n",
        "        ).add_to(m)\n",
        "    st_folium(m, width=700, height=500)\n"
      ],
      "metadata": {
        "id": "DGZYldwVfdpY"
      },
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyNwy9LB+mqPnK2nrLmPQIWA",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}